<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>THE-AKIKO</title>
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icon192x192.png">
    <link rel="icon" href="icon192x192.png">
    <script>
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js');
        }
    </script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'HiraMinProN-W6', 'Mincho', serif; touch-action: none; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        #score-board { color: white; font-size: 24px; padding: 20px; text-shadow: 0 0 5px red; font-weight: bold; position: absolute; top: 0; left: 0; z-index: 2; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; border: 2px solid lime; border-radius: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 10px lime; pointer-events: none; }
        #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; z-index: 10; }
        h1 { color: #ff3366; font-size: 40px; margin-bottom: 10px; text-align: center; }
        p { color: #ddd; font-size: 18px; text-align: center; margin-bottom: 20px; line-height: 1.6; }
        button#start-btn { padding: 15px 40px; font-size: 24px; background: #ff3366; color: white; border: none; border-radius: 5px; cursor: pointer; font-family: serif; }
        button#start-btn:active { background: #cc0033; }
        
        /* ミニマップ (レーダー) のスタイル */
        #minimap-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 120px;
            height: 120px;
            background: rgba(0, 20, 0, 0.7); /* 暗視スコープ風の背景 */
            border: 2px solid rgba(0, 255, 0, 0.6);
            border-radius: 50%;
            z-index: 5;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
            pointer-events: none; /* クリックを透過 */
        }
        #minimap {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* モバイルコントロールの基本設定 */
        #mobile-controls { position: absolute; width: 100%; height: 100%; display: none; pointer-events: none; top: 0; left: 0; }
        .control-zone { width: 50%; height: 100%; pointer-events: auto; position: absolute; bottom: 0; z-index: 5; }
        #left-zone { left: 0; } 
        #right-zone { right: 0; } 
        
        #fire-btn { 
            position: absolute; width: 80px; height: 80px; 
            background: rgba(255, 51, 102, 0.5); border: 2px solid white; border-radius: 50%; 
            pointer-events: auto; display: flex; align-items: center; justify-content: center; 
            color: white; font-weight: bold; user-select: none;
            z-index: 6;
        }

        /* PC表示 */
        .pc-only { display: none; }
        @media (min-width: 1024px) {
            .pc-only { display: inline; }
            .mobile-only { display: none; }
            #mobile-controls { display: none !important; }
        }

        /* スマホ縦画面 (Portrait) */
        @media (max-width: 1023px) and (orientation: portrait) {
            #mobile-controls { display: block; }
            .control-zone { height: 40%; bottom: 0; }
            #fire-btn { bottom: 40px; right: 20px; }
            /* 縦画面時はレーダーを少し下げる（指と被らないように） */
            #minimap-container { top: 60px; right: 20px; width: 100px; height: 100px; }
        }

        /* スマホ横画面 (Landscape) */
        @media (max-width: 1023px) and (orientation: landscape) {
            #mobile-controls { display: block; }
            .control-zone { height: 100%; top: 0; }
            #fire-btn { bottom: 30px; right: 30px; width: 70px; height: 70px; font-size: 14px; }
            h1 { font-size: 32px; }
            /* 横画面時は右上のスペースを活用 */
            #minimap-container { top: 15px; right: 15px; width: 100px; height: 100px; }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="ui-layer">
        <div id="score-board">撃墜数: <span id="score">0</span></div>
        
        <div id="minimap-container">
            <canvas id="minimap" width="120" height="120"></canvas>
        </div>

        <div id="crosshair"></div>
    </div>
    <div id="mobile-controls">
        <div id="left-zone" class="control-zone"></div>
        <div id="right-zone" class="control-zone"></div>
        <div id="fire-btn">撃て</div>
    </div>
    <div id="overlay">
        <h1>THE-AKIKO</h1>
        <p>
            君、死にたまふことなかれ。<br>
            迫りくる晶子たちをレーザーで撃ち落とせ。<br><br>
            <span class="pc-only">【操作: PC】<br>WASD: 移動 | マウス: 視点<br>クリック: 射撃</span>
            <span class="mobile-only">【操作: スマホ】<br>左半分ドラッグ: 移動 | 右半分ドラッグ: 視点<br>ボタン: 射撃<br>※横画面・コントローラー対応</span>
        </p>
        <button id="start-btn">迎撃開始</button>
    </div>
    <footer>
        <a href="https://github.com/iamthe000/YosanoGame/">このゲームのソースコードはGitHubで公開されています</a>
        <a href="https://x.com/juuur_zyura">作者</a>
    </footer>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let isGameRunning = false;
        let score = 0;
        let spawnRate = 100; 
        let enemySpeed = 0.05;
        const playerSpeed = 0.15; // プレイヤーの最大移動速度
        let projectiles = [];
        let enemies = [];
        let frame = 0;

        // コントローラー連射制御用
        let lastShotTime = 0;
        const shotCooldown = 15; 

        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x110505); 
        scene.fog = new THREE.Fog(0x110505, 10, 50);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.rotation.order = "YXZ"; 
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
        container.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xff3366, 1, 50);
        pointLight.position.set(0, 10, 0);
        scene.add(pointLight);

        const gridHelper = new THREE.GridHelper(200, 200, 0xff3366, 0x333333);
        scene.add(gridHelper);

        const planeGeometry = new THREE.PlaneGeometry(200, 200);
        const planeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, visible: false });
        const floor = new THREE.Mesh(planeGeometry, planeMaterial);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        let akikoMaterial;
        const textureLoader = new THREE.TextureLoader();
        textureLoader.load(
            './Akiko.png', 
            (texture) => { akikoMaterial = new THREE.SpriteMaterial({ map: texture }); },
            undefined,
            (err) => {
                const canvas = document.createElement('canvas');
                canvas.width = 64; canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'red'; ctx.fillRect(0,0,64,64);
                const fallbackTexture = new THREE.CanvasTexture(canvas);
                akikoMaterial = new THREE.SpriteMaterial({ map: fallbackTexture });
            }
        );

        const keys = { w: false, a: false, s: false, d: false };
        let mobileMove = { x: 0, y: 0 }; 
        
        document.addEventListener('keydown', (e) => { if(keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = true; });
        document.addEventListener('keyup', (e) => { if(keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = false; });
        
        document.addEventListener('click', () => {
            if (isGameRunning) {
                if(!isMobile() && document.pointerLockElement !== document.body) {
                    document.body.requestPointerLock();
                }
                if(!isMobile()) shoot();
            }
        });
        
        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement === document.body) {
                camera.rotation.y -= e.movementX * 0.002;
                camera.rotation.x -= e.movementY * 0.002;
                camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
            }
        });

        const leftZone = document.getElementById('left-zone');
        const rightZone = document.getElementById('right-zone');
        const fireBtn = document.getElementById('fire-btn');
        let touchStartPos = { left: null, right: null };

        function handleTouchStart(e, side) {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                touchStartPos[side] = { id: t.identifier, x: t.clientX, y: t.clientY };
            }
        }

        function handleTouchMove(e, side) {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                if (touchStartPos[side] && touchStartPos[side].id === t.identifier) {
                    const dx = t.clientX - touchStartPos[side].x;
                    const dy = t.clientY - touchStartPos[side].y;
                    
                    if (side === 'left') {
                        // 【修正】移動感度の調整
                        const moveSensitivity = 0.01; 
                        
                        mobileMove.x = dx * moveSensitivity;
                        mobileMove.y = dy * moveSensitivity;

                        // 【重要】最大値を1.0に制限（クランプ）
                        mobileMove.x = Math.max(-1, Math.min(1, mobileMove.x));
                        mobileMove.y = Math.max(-1, Math.min(1, mobileMove.y));

                    } else {
                        // 視点感度
                        const lookSensitivity = 0.004;
                        camera.rotation.y -= dx * lookSensitivity;
                        camera.rotation.x -= dy * lookSensitivity;
                        camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
                        
                        touchStartPos[side].x = t.clientX; 
                        touchStartPos[side].y = t.clientY;
                    }
                }
            }
        }

        function handleTouchEnd(e, side) {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (touchStartPos[side] && touchStartPos[side].id === e.changedTouches[i].identifier) {
                    touchStartPos[side] = null;
                    if (side === 'left') { mobileMove = { x: 0, y: 0 }; }
                }
            }
        }

        leftZone.addEventListener('touchstart', (e) => handleTouchStart(e, 'left'), {passive: false});
        leftZone.addEventListener('touchmove', (e) => handleTouchMove(e, 'left'), {passive: false});
        leftZone.addEventListener('touchend', (e) => handleTouchEnd(e, 'left'), {passive: false});

        rightZone.addEventListener('touchstart', (e) => handleTouchStart(e, 'right'), {passive: false});
        rightZone.addEventListener('touchmove', (e) => handleTouchMove(e, 'right'), {passive: false});
        rightZone.addEventListener('touchend', (e) => handleTouchEnd(e, 'right'), {passive: false});

        fireBtn.addEventListener('touchstart', (e) => {
            e.preventDefault(); 
            if(isGameRunning) shoot();
        }, {passive: false});

        function isMobile() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        function resetGame() {
            score = 0;
            spawnRate = 100;
            enemySpeed = 0.05;
            document.getElementById('score').innerText = score;
            
            enemies.forEach(e => scene.remove(e));
            projectiles.forEach(p => scene.remove(p));
            enemies = [];
            projectiles = [];
            
            camera.position.set(0, 1.6, 0); 
            camera.rotation.set(0, 0, 0);
            
            isGameRunning = true;
            document.getElementById('overlay').style.display = 'none';
        }

        function gameOver() {
            isGameRunning = false;

            document.querySelector('#overlay h1').innerText = "GAME OVER";
            document.querySelector('#overlay p').innerHTML = `撃墜数: ${score}体<br>君は死にたまひぬ。`;
            document.getElementById('start-btn').innerText = "再挑戦";
            document.getElementById('overlay').style.display = 'flex';

            if (document.exitPointerLock) {
                document.exitPointerLock();
            }
        }

        function shoot() {
            const geometry = new THREE.SphereGeometry(0.1, 8, 8);
            const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const bullet = new THREE.Mesh(geometry, material);
            
            bullet.position.copy(camera.position);
            bullet.position.y += 0.2; 
            
            const cameraDir = new THREE.Vector3();
            camera.getWorldDirection(cameraDir);
            
            const targetPoint = new THREE.Vector3().copy(camera.position).add(cameraDir.multiplyScalar(100));

            const bulletDirection = new THREE.Vector3();
            bulletDirection.subVectors(targetPoint, bullet.position).normalize();

            bullet.velocity = bulletDirection.multiplyScalar(1.0); 
            
            scene.add(bullet);
            projectiles.push(bullet);
        }


        function spawnEnemy() {
            if (!akikoMaterial) return; 

            const sprite = new THREE.Sprite(akikoMaterial);
            sprite.scale.set(1.5, 1.5, 1);
            
            const angle = Math.random() * Math.PI * 2;
            const radius = 30 + Math.random() * 10; 
            
            sprite.position.set(
                camera.position.x + Math.cos(angle) * radius,
                1.5, 
                camera.position.z + Math.sin(angle) * radius
            );
            
            scene.add(sprite);
            enemies.push(sprite);
        }

        function handleGamepad() {
            const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
            if (!gamepads) return;

            const gp = gamepads[0];
            if (gp) {
                const deadzone = 0.1;

                const moveX = Math.abs(gp.axes[0]) > deadzone ? gp.axes[0] : 0;
                const moveY = Math.abs(gp.axes[1]) > deadzone ? gp.axes[1] : 0;
                const lookX = Math.abs(gp.axes[2]) > deadzone ? gp.axes[2] : 0;
                const lookY = Math.abs(gp.axes[3]) > deadzone ? gp.axes[3] : 0;

                if (moveX !== 0 || moveY !== 0 || lookX !== 0 || lookY !== 0) {
                    const direction = new THREE.Vector3();
                    camera.getWorldDirection(direction);
                    direction.y = 0; 
                    direction.normalize();
                    const right = new THREE.Vector3();
                    right.crossVectors(direction, camera.up).normalize(); 

                    camera.position.addScaledVector(direction, -moveY * playerSpeed);
                    camera.position.addScaledVector(right, moveX * playerSpeed);

                    camera.rotation.y -= lookX * 0.03;
                    camera.rotation.x -= lookY * 0.03;
                    camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
                }

                if (gp.buttons[0].pressed || gp.buttons[7].pressed) {
                    if (frame - lastShotTime > shotCooldown) {
                        shoot();
                        lastShotTime = frame;
                    }
                }
            }
        }

        // --- ミニマップ処理の実装 ---
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');
        // Canvasのサイズは120x120
        const minimapCenter = 60; 
        const radarRange = 40; // レーダーの検知範囲 (メートル)

        function updateMinimap() {
            // クリア
            minimapCtx.clearRect(0, 0, 120, 120);

            // レーダーの背景グリッド線（オプション）
            minimapCtx.strokeStyle = 'rgba(0, 255, 0, 0.2)';
            minimapCtx.lineWidth = 1;
            minimapCtx.beginPath();
            minimapCtx.arc(minimapCenter, minimapCenter, 30, 0, Math.PI * 2); // 距離円
            minimapCtx.stroke();
            
            // プレイヤー（中心に固定）を描画
            minimapCtx.fillStyle = '#00ff00';
            minimapCtx.beginPath();
            // 三角形で向きを表現（常に上向き）
            minimapCtx.moveTo(minimapCenter, minimapCenter - 5);
            minimapCtx.lineTo(minimapCenter - 4, minimapCenter + 4);
            minimapCtx.lineTo(minimapCenter + 4, minimapCenter + 4);
            minimapCtx.fill();

            // 敵を描画（プレイヤー中心で回転させる）
            // レーダー上では、Y軸マイナス（上）がプレイヤーの正面
            
            // 1. プレイヤーの向いている方向ベクトルを取得
            const pDir = new THREE.Vector3();
            camera.getWorldDirection(pDir);
            pDir.y = 0; pDir.normalize();

            // 2. プレイヤーの右方向ベクトルを取得
            const pRight = new THREE.Vector3();
            pRight.crossVectors(pDir, camera.up).normalize();

            minimapCtx.fillStyle = '#ff3366'; // 晶子カラー

            enemies.forEach(enemy => {
                // プレイヤーから敵への相対ベクトル
                const rel = new THREE.Vector3().subVectors(enemy.position, camera.position);
                const dist = rel.length();

                if (dist < radarRange) {
                    // 相対位置をプレイヤーのローカル座標系（前後・左右）に投影する
                    // 前後成分 (Forward distance)
                    const forwardDist = rel.dot(pDir);
                    // 左右成分 (Right distance)
                    const rightDist = rel.dot(pRight);

                    // Canvas上の座標に変換
                    // X: 左右 (右がプラス)
                    // Y: 前後 (前がマイナス＝上)
                    const mapX = minimapCenter + (rightDist / radarRange) * minimapCenter;
                    const mapY = minimapCenter - (forwardDist / radarRange) * minimapCenter;

                    // 点を描画
                    minimapCtx.beginPath();
                    minimapCtx.arc(mapX, mapY, 3, 0, Math.PI * 2);
                    minimapCtx.fill();
                }
            });
        }
        // ---------------------------

        function animate() {
            requestAnimationFrame(animate);

            if (!isGameRunning) return;

            frame++;

            handleGamepad();

            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            direction.y = 0; 
            direction.normalize();
            
            const right = new THREE.Vector3();
            right.crossVectors(direction, camera.up).normalize(); 

            if (keys.w) { camera.position.addScaledVector(direction, playerSpeed); }
            if (keys.s) { camera.position.addScaledVector(direction, -playerSpeed); }
            if (keys.d) { camera.position.addScaledVector(right, playerSpeed); }
            if (keys.a) { camera.position.addScaledVector(right, -playerSpeed); }

            // スマホタッチ操作の適用
            if (Math.abs(mobileMove.x) > 0 || Math.abs(mobileMove.y) > 0) {
                camera.position.addScaledVector(direction, -mobileMove.y * playerSpeed); 
                camera.position.addScaledVector(right, mobileMove.x * playerSpeed);
            }

            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.position.add(p.velocity);
                
                if (p.position.distanceTo(camera.position) > 60) {
                    scene.remove(p);
                    projectiles.splice(i, 1);
                    continue;
                }

                for (let j = enemies.length - 1; j >= 0; j--) {
                    const e = enemies[j];
                    if (p.position.distanceTo(e.position) < 1.0) { 
                        scene.remove(e);
                        enemies.splice(j, 1);
                        scene.remove(p);
                        projectiles.splice(i, 1);
                        
                        score++;
                        document.getElementById('score').innerText = score;
                        
                        if(score % 5 === 0) spawnRate = Math.max(20, spawnRate - 5);
                        if(score % 10 === 0) enemySpeed += 0.005;
                        
                        break; 
                    }
                }
            }

            if (frame % spawnRate === 0) {
                spawnEnemy();
            }

            for (let i = 0; i < enemies.length; i++) {
                const e = enemies[i];
                const dir = new THREE.Vector3();
                dir.subVectors(camera.position, e.position).normalize();
                dir.y = 0; 
                e.position.addScaledVector(dir, enemySpeed);

                if (e.position.distanceTo(camera.position) < 1.5) {
                    gameOver();
                }
            }

            // ミニマップ更新
            updateMinimap();

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        document.getElementById('start-btn').addEventListener('click', resetGame);

        animate();
    </script>
</body>
</html>
