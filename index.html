<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>THE-AKIKO (Dev Tools Ver)</title>
    <link rel="manifest" href="manifest.json">
    <script>
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js');
        }
    </script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'HiraMinProN-W6', 'Mincho', serif; touch-action: none; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        
        /* スコアの位置を少し調整（開発者ツールと被らないように） */
        #score-board { color: white; font-size: 24px; padding: 20px; text-shadow: 0 0 5px red; font-weight: bold; position: absolute; top: 0; right: 20px; text-align: right; z-index: 2; }
        
        #crosshair { position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; border: 2px solid lime; border-radius: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 10px lime; pointer-events: none; }
        
        /* 設定ボタン */
        #settings-btn {
            position: absolute; top: 60px; right: 20px; 
            font-size: 24px; background: rgba(0,0,0,0.5); color: white; border: 1px solid white;
            width: 40px; height: 40px; border-radius: 50%; cursor: pointer; pointer-events: auto; z-index: 20;
            display: flex; justify-content: center; align-items: center;
        }
        #settings-btn:hover { background: rgba(255, 51, 102, 0.5); }

        #overlay, #settings-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: flex; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; z-index: 30; }
        #settings-overlay { display: none; z-index: 40; } 

        h1 { color: #ff3366; font-size: 40px; margin-bottom: 10px; text-align: center; }
        h2 { color: #fff; border-bottom: 1px solid #ff3366; padding-bottom: 5px; margin-bottom: 20px;}
        p { color: #ddd; font-size: 18px; text-align: center; margin-bottom: 20px; line-height: 1.6; }
        
        button.menu-btn { padding: 10px 30px; font-size: 20px; background: #ff3366; color: white; border: none; border-radius: 5px; cursor: pointer; font-family: serif; margin-top: 20px; }
        button.menu-btn:active { background: #cc0033; }
        
        /* 設定メニュー内のスタイル */
        .setting-item { margin-bottom: 15px; width: 80%; max-width: 300px; color: white; text-align: left; }
        .setting-item label { display: inline-block; width: 100%; margin-bottom: 5px; font-weight: bold; }
        .setting-item input[type="range"] { width: 100%; cursor: pointer; }
        .setting-item input[type="checkbox"] { transform: scale(1.5); margin-right: 10px; cursor: pointer; }
        .setting-row { display: flex; align-items: center; margin-bottom: 10px; }

        #minimap-container {
            position: absolute;
            bottom: 20px; /* 位置を右下に変更 */
            right: 20px;
            width: 120px;
            height: 120px;
            background: rgba(0, 20, 0, 0.7);
            border: 2px solid rgba(0, 255, 0, 0.6);
            border-radius: 50%;
            z-index: 5;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
            pointer-events: none;
            transition: opacity 0.3s;
        }
        #minimap { width: 100%; height: 100%; display: block; }

        #mobile-controls { position: absolute; width: 100%; height: 100%; display: none; pointer-events: none; top: 0; left: 0; }
        .control-zone { width: 50%; height: 100%; pointer-events: auto; position: absolute; bottom: 0; z-index: 5; }
        #left-zone { left: 0; } 
        #right-zone { right: 0; } 
        
        #fire-btn { 
            position: absolute; width: 80px; height: 80px; 
            background: rgba(255, 51, 102, 0.5); border: 2px solid white; border-radius: 50%; 
            pointer-events: auto; display: flex; align-items: center; justify-content: center; 
            color: white; font-weight: bold; user-select: none;
            z-index: 6;
        }

        .pc-only { display: none; }
        @media (min-width: 1024px) {
            .pc-only { display: inline; }
            .mobile-only { display: none; }
            #mobile-controls { display: none !important; }
        }

        @media (max-width: 1023px) and (orientation: portrait) {
            #mobile-controls { display: block; }
            .control-zone { height: 40%; bottom: 0; }
            #fire-btn { bottom: 150px; right: 20px; } /* ミニマップと被らないように調整 */
            #minimap-container { bottom: 20px; right: 20px; width: 100px; height: 100px; }
            #settings-btn { top: 20px; left: 20px; right: auto; } /* スマホ縦は左上に配置 */
            #score-board { top: 0; right: 0; width: 100%; text-align: center; }
        }

        @media (max-width: 1023px) and (orientation: landscape) {
            #mobile-controls { display: block; }
            .control-zone { height: 100%; top: 0; }
            #fire-btn { bottom: 30px; right: 30px; width: 70px; height: 70px; font-size: 14px; }
            h1 { font-size: 32px; }
            #minimap-container { top: 15px; right: 15px; width: 100px; height: 100px; bottom: auto; }
            #settings-btn { top: 15px; right: 130px; }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="ui-layer">
        <div id="score-board">撃墜数: <span id="score">0</span></div>
        <button id="settings-btn" title="設定">⚙️</button>
        <div id="minimap-container">
            <canvas id="minimap" width="120" height="120"></canvas>
        </div>
        <div id="crosshair"></div>
    </div>
    
    <div id="mobile-controls">
        <div id="left-zone" class="control-zone"></div>
        <div id="right-zone" class="control-zone"></div>
        <div id="fire-btn">撃て</div>
    </div>

    <div id="overlay">
        <h1>THE-AKIKO</h1>
        <p>
            君、死にたまふことなかれ。<br>
            迫りくる晶子たちをレーザーで撃ち落とせ。<br><br>
            <span class="pc-only">【操作: PC】<br>WASD: 移動 | マウス: 視点<br>クリック: 射撃</span>
            <span class="mobile-only">【操作: スマホ】<br>左半分ドラッグ: 移動 | 右半分ドラッグ: 視点<br>ボタン: 射撃<br>※横画面・コントローラー対応</span>
        </p>
        <button id="start-btn" class="menu-btn">迎撃開始</button> 
        <a href="https://github.com/iamthe000/YosanoGame/" style="color:#666; font-size: 12px; margin-top:20px;">GitHub</a>
    </div>

    <div id="settings-overlay">
        <h2>環境設定</h2>
        
        <div class="setting-item">
            <label for="sens-slider">視点感度: <span id="sens-val">1.0</span></label>
            <input type="range" id="sens-slider" min="0.1" max="3.0" step="0.1" value="1.0">
        </div>

        <div class="setting-item setting-row">
            <input type="checkbox" id="debug-check">
            <label for="debug-check">開発者ツール (FPS/Hitbox)</label>
        </div>

        <div class="setting-item setting-row">
            <input type="checkbox" id="minimap-check" checked>
            <label for="minimap-check">ミニマップを表示</label>
        </div>

        <button id="close-settings-btn" class="menu-btn">閉じる</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r17/Stats.min.js"></script>
    <script>
        let isGameRunning = false;
        let isSettingsOpen = false; 
        let score = 0;
        let spawnRate = 100; 
        let enemySpeed = 0.05;
        const playerSpeed = 0.15;
        let projectiles = [];
        let enemies = [];
        let frame = 0;

        // 設定値
        let config = {
            sensitivity: 1.0,
            debugMode: false, // 開発者モード（旧Hitbox）
            showMinimap: true
        };

        // Stats初期化
        const stats = new Stats();
        stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom
        stats.dom.style.position = 'absolute';
        stats.dom.style.top = '0px';
        stats.dom.style.left = '0px';
        stats.dom.style.zIndex = '100';
        stats.dom.style.display = 'none'; // 初期は非表示
        document.body.appendChild(stats.dom);

        let lastShotTime = 0;
        const shotCooldown = 15; 

        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x110505); 
        scene.fog = new THREE.Fog(0x110505, 10, 50);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.rotation.order = "YXZ"; 
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
        container.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xff3366, 1, 50);
        pointLight.position.set(0, 10, 0);
        scene.add(pointLight);

        const gridHelper = new THREE.GridHelper(200, 200, 0xff3366, 0x333333);
        scene.add(gridHelper);

        const planeGeometry = new THREE.PlaneGeometry(200, 200);
        const planeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, visible: false });
        const floor = new THREE.Mesh(planeGeometry, planeMaterial);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        // プレイヤーの当たり判定表示用
        const playerHitboxGeo = new THREE.SphereGeometry(1.5, 8, 8); 
        const playerHitboxMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true, visible: false });
        const playerHitbox = new THREE.Mesh(playerHitboxGeo, playerHitboxMat);
        scene.add(playerHitbox);

        let akikoMaterial;
        const textureLoader = new THREE.TextureLoader();
        textureLoader.load(
            './Akiko.png', 
            (texture) => { akikoMaterial = new THREE.SpriteMaterial({ map: texture }); },
            undefined,
            (err) => {
                const canvas = document.createElement('canvas');
                canvas.width = 64; canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'red'; ctx.fillRect(0,0,64,64);
                const fallbackTexture = new THREE.CanvasTexture(canvas);
                akikoMaterial = new THREE.SpriteMaterial({ map: fallbackTexture });
            }
        );

        const keys = { w: false, a: false, s: false, d: false };
        let mobileMove = { x: 0, y: 0 }; 
        
        document.addEventListener('keydown', (e) => { if(keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = true; });
        document.addEventListener('keyup', (e) => { if(keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = false; });
        
        document.addEventListener('click', (e) => {
            if (e.target.closest('#settings-btn') || e.target.closest('#settings-overlay')) return;

            if (isGameRunning && !isSettingsOpen) {
                if(!isMobile() && document.pointerLockElement !== document.body) {
                    document.body.requestPointerLock();
                }
                if(!isMobile()) shoot();
            }
        });
        
        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement === document.body && !isSettingsOpen) {
                camera.rotation.y -= e.movementX * 0.002 * config.sensitivity;
                camera.rotation.x -= e.movementY * 0.002 * config.sensitivity;
                camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
            }
        });

        const leftZone = document.getElementById('left-zone');
        const rightZone = document.getElementById('right-zone');
        const fireBtn = document.getElementById('fire-btn');
        let touchStartPos = { left: null, right: null };

        function handleTouchStart(e, side) {
            if (isSettingsOpen) return;
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                touchStartPos[side] = { id: t.identifier, x: t.clientX, y: t.clientY };
            }
        }

        function handleTouchMove(e, side) {
            if (isSettingsOpen) return;
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                if (touchStartPos[side] && touchStartPos[side].id === t.identifier) {
                    const dx = t.clientX - touchStartPos[side].x;
                    const dy = t.clientY - touchStartPos[side].y;
                    
                    if (side === 'left') {
                        const moveSensitivity = 0.01; 
                        mobileMove.x = dx * moveSensitivity;
                        mobileMove.y = dy * moveSensitivity;
                        mobileMove.x = Math.max(-1, Math.min(1, mobileMove.x));
                        mobileMove.y = Math.max(-1, Math.min(1, mobileMove.y));
                    } else {
                        const lookSensitivity = 0.004 * config.sensitivity; 
                        camera.rotation.y -= dx * lookSensitivity;
                        camera.rotation.x -= dy * lookSensitivity;
                        camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
                        touchStartPos[side].x = t.clientX; 
                        touchStartPos[side].y = t.clientY;
                    }
                }
            }
        }

        function handleTouchEnd(e, side) {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (touchStartPos[side] && touchStartPos[side].id === e.changedTouches[i].identifier) {
                    touchStartPos[side] = null;
                    if (side === 'left') { mobileMove = { x: 0, y: 0 }; }
                }
            }
        }

        leftZone.addEventListener('touchstart', (e) => handleTouchStart(e, 'left'), {passive: false});
        leftZone.addEventListener('touchmove', (e) => handleTouchMove(e, 'left'), {passive: false});
        leftZone.addEventListener('touchend', (e) => handleTouchEnd(e, 'left'), {passive: false});

        rightZone.addEventListener('touchstart', (e) => handleTouchStart(e, 'right'), {passive: false});
        rightZone.addEventListener('touchmove', (e) => handleTouchMove(e, 'right'), {passive: false});
        rightZone.addEventListener('touchend', (e) => handleTouchEnd(e, 'right'), {passive: false});

        fireBtn.addEventListener('touchstart', (e) => {
            e.preventDefault(); 
            if(isGameRunning && !isSettingsOpen) shoot();
        }, {passive: false});

        function isMobile() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        function resetGame() {
            score = 0;
            spawnRate = 100;
            enemySpeed = 0.05;
            document.getElementById('score').innerText = score;
            
            enemies.forEach(e => {
                scene.remove(e.sprite);
                if(e.hitbox) scene.remove(e.hitbox);
            });
            projectiles.forEach(p => scene.remove(p));
            enemies = [];
            projectiles = [];
            
            camera.position.set(0, 1.6, 0); 
            camera.rotation.set(0, 0, 0);
            
            isGameRunning = true;
            isSettingsOpen = false;
            document.getElementById('overlay').style.display = 'none';
        }

        function gameOver() {
            isGameRunning = false;
            document.querySelector('#overlay h1').innerText = "GAME OVER";
            document.querySelector('#overlay p').innerHTML = `撃墜数: ${score}体<br>君は死にたまひぬ。`;
            document.getElementById('start-btn').innerText = "再挑戦";
            document.getElementById('overlay').style.display = 'flex';
            if (document.exitPointerLock) {
                document.exitPointerLock();
            }
        }

        function shoot() {
            const geometry = new THREE.SphereGeometry(0.1, 8, 8);
            const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const bullet = new THREE.Mesh(geometry, material);
            bullet.position.copy(camera.position);
            bullet.position.y += 0.2; 
            const cameraDir = new THREE.Vector3();
            camera.getWorldDirection(cameraDir);
            const targetPoint = new THREE.Vector3().copy(camera.position).add(cameraDir.multiplyScalar(100));
            const bulletDirection = new THREE.Vector3();
            bulletDirection.subVectors(targetPoint, bullet.position).normalize();
            bullet.velocity = bulletDirection.multiplyScalar(1.0); 
            scene.add(bullet);
            projectiles.push(bullet);
        }

        function spawnEnemy() {
            if (!akikoMaterial) return; 
            const sprite = new THREE.Sprite(akikoMaterial);
            sprite.scale.set(1.5, 1.5, 1);
            const angle = Math.random() * Math.PI * 2;
            const radius = 30 + Math.random() * 10; 
            sprite.position.set(
                camera.position.x + Math.cos(angle) * radius,
                1.5, 
                camera.position.z + Math.sin(angle) * radius
            );
            scene.add(sprite);

            const hitboxGeo = new THREE.SphereGeometry(1.0, 8, 8);
            const hitboxMat = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true, visible: config.debugMode });
            const hitbox = new THREE.Mesh(hitboxGeo, hitboxMat);
            hitbox.position.copy(sprite.position);
            scene.add(hitbox);

            enemies.push({ sprite: sprite, hitbox: hitbox });
        }

        // --- 設定メニュー制御 ---
        const settingsBtn = document.getElementById('settings-btn');
        const settingsOverlay = document.getElementById('settings-overlay');
        const closeSettingsBtn = document.getElementById('close-settings-btn');
        const sensSlider = document.getElementById('sens-slider');
        const sensVal = document.getElementById('sens-val');
        const debugCheck = document.getElementById('debug-check');
        const minimapCheck = document.getElementById('minimap-check');
        const minimapContainer = document.getElementById('minimap-container');

        settingsBtn.addEventListener('click', () => {
            isSettingsOpen = true;
            settingsOverlay.style.display = 'flex';
            if (document.exitPointerLock) {
                document.exitPointerLock(); 
            }
        });

        closeSettingsBtn.addEventListener('click', () => {
            isSettingsOpen = false;
            settingsOverlay.style.display = 'none';
            if (isGameRunning && !isMobile() && document.pointerLockElement !== document.body) {
                document.body.requestPointerLock();
            }
        });

        sensSlider.addEventListener('input', (e) => {
            config.sensitivity = parseFloat(e.target.value);
            sensVal.innerText = config.sensitivity.toFixed(1);
        });

        // 開発者モード切り替え (Hitbox + Stats)
        debugCheck.addEventListener('change', (e) => {
            config.debugMode = e.target.checked;
            
            // Hitboxの表示切替
            enemies.forEach(e => {
                if(e.hitbox) e.hitbox.material.visible = config.debugMode;
            });
            playerHitbox.material.visible = config.debugMode;

            // Statsグラフの表示切替
            stats.dom.style.display = config.debugMode ? 'block' : 'none';
        });

        minimapCheck.addEventListener('change', (e) => {
            config.showMinimap = e.target.checked;
            minimapContainer.style.opacity = config.showMinimap ? '1' : '0';
        });

        // --- コントローラー制御 ---
        function handleGamepad() {
            if (isSettingsOpen) return;
            const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
            let gp = null;
            for (let i = 0; i < gamepads.length; i++) {
                if (gamepads[i] && gamepads[i].connected) {
                    gp = gamepads[i];
                    break;
                }
            }
            if (!gp) return;

            const deadzone = 0.1;
            const moveX = gp.axes[0] ? (Math.abs(gp.axes[0]) > deadzone ? gp.axes[0] : 0) : 0;
            const moveY = gp.axes[1] ? (Math.abs(gp.axes[1]) > deadzone ? gp.axes[1] : 0) : 0;
            const lookX = gp.axes[2] ? (Math.abs(gp.axes[2]) > deadzone ? gp.axes[2] : 0) : 0;
            const lookY = gp.axes[3] ? (Math.abs(gp.axes[3]) > deadzone ? gp.axes[3] : 0) : 0;

            if (moveX !== 0 || moveY !== 0 || lookX !== 0 || lookY !== 0) {
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                direction.y = 0; 
                direction.normalize();
                const right = new THREE.Vector3();
                right.crossVectors(direction, camera.up).normalize(); 

                camera.position.addScaledVector(direction, -moveY * playerSpeed);
                camera.position.addScaledVector(right, moveX * playerSpeed);

                camera.rotation.y -= lookX * 0.03 * config.sensitivity;
                camera.rotation.x -= lookY * 0.03 * config.sensitivity;
                camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
            }

            let isFirePressed = false;
            for (let i = 0; i < 8; i++) {
                if (gp.buttons[i] && (gp.buttons[i].pressed || gp.buttons[i].value > 0.5)) {
                    isFirePressed = true;
                    break;
                }
            }

            if (isFirePressed) {
                if (frame - lastShotTime > shotCooldown) {
                    shoot();
                    lastShotTime = frame;
                }
            }
        }

        // --- ミニマップ処理 ---
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');
        const minimapCenter = 60; 
        const radarRange = 40; 

        function updateMinimap() {
            if (!config.showMinimap) return;

            minimapCtx.clearRect(0, 0, 120, 120);
            minimapCtx.strokeStyle = 'rgba(0, 255, 0, 0.2)';
            minimapCtx.lineWidth = 1;
            minimapCtx.beginPath();
            minimapCtx.arc(minimapCenter, minimapCenter, 30, 0, Math.PI * 2);
            minimapCtx.stroke();
            
            minimapCtx.fillStyle = '#00ff00';
            minimapCtx.beginPath();
            minimapCtx.moveTo(minimapCenter, minimapCenter - 5);
            minimapCtx.lineTo(minimapCenter - 4, minimapCenter + 4);
            minimapCtx.lineTo(minimapCenter + 4, minimapCenter + 4);
            minimapCtx.fill();

            const pDir = new THREE.Vector3();
            camera.getWorldDirection(pDir);
            pDir.y = 0; pDir.normalize();
            const pRight = new THREE.Vector3();
            pRight.crossVectors(pDir, camera.up).normalize();

            minimapCtx.fillStyle = '#ff3366'; 

            enemies.forEach(enemyData => {
                const enemy = enemyData.sprite;
                const rel = new THREE.Vector3().subVectors(enemy.position, camera.position);
                const dist = rel.length();
                if (dist < radarRange) {
                    const forwardDist = rel.dot(pDir);
                    const rightDist = rel.dot(pRight);
                    const mapX = minimapCenter + (rightDist / radarRange) * minimapCenter;
                    const mapY = minimapCenter - (forwardDist / radarRange) * minimapCenter;
                    minimapCtx.beginPath();
                    minimapCtx.arc(mapX, mapY, 3, 0, Math.PI * 2);
                    minimapCtx.fill();
                }
            });
        }

        function animate() {
            // Stats 計測開始
            stats.begin();

            requestAnimationFrame(animate);
            
            renderer.render(scene, camera);

            if (!isGameRunning || isSettingsOpen) {
                stats.end(); // 停止中でも計測終了を呼ぶ
                return;
            }
            
            frame++;
            
            handleGamepad();

            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            direction.y = 0; 
            direction.normalize();
            const right = new THREE.Vector3();
            right.crossVectors(direction, camera.up).normalize(); 

            if (keys.w) { camera.position.addScaledVector(direction, playerSpeed); }
            if (keys.s) { camera.position.addScaledVector(direction, -playerSpeed); }
            if (keys.d) { camera.position.addScaledVector(right, playerSpeed); }
            if (keys.a) { camera.position.addScaledVector(right, -playerSpeed); }

            if (Math.abs(mobileMove.x) > 0 || Math.abs(mobileMove.y) > 0) {
                camera.position.addScaledVector(direction, -mobileMove.y * playerSpeed); 
                camera.position.addScaledVector(right, mobileMove.x * playerSpeed);
            }

            playerHitbox.position.copy(camera.position);

            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.position.add(p.velocity);
                if (p.position.distanceTo(camera.position) > 60) {
                    scene.remove(p);
                    projectiles.splice(i, 1);
                    continue;
                }
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const eData = enemies[j];
                    const e = eData.sprite;
                    if (p.position.distanceTo(e.position) < 1.0) { 
                        scene.remove(e);
                        if(eData.hitbox) scene.remove(eData.hitbox);
                        enemies.splice(j, 1);
                        scene.remove(p);
                        projectiles.splice(i, 1);
                        score++;
                        document.getElementById('score').innerText = score;
                        if(score % 5 === 0) spawnRate = Math.max(20, spawnRate - 5);
                        if(score % 10 === 0) enemySpeed += 0.005;
                        break; 
                    }
                }
            }

            if (frame % spawnRate === 0) {
                spawnEnemy();
            }

            for (let i = 0; i < enemies.length; i++) {
                const eData = enemies[i];
                const e = eData.sprite;
                const dir = new THREE.Vector3();
                dir.subVectors(camera.position, e.position).normalize();
                dir.y = 0; 
                e.position.addScaledVector(dir, enemySpeed);
                
                if(eData.hitbox) eData.hitbox.position.copy(e.position);

                if (e.position.distanceTo(camera.position) < 1.5) {
                    gameOver();
                }
            }
            updateMinimap();

            // Stats 計測終了
            stats.end();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        document.getElementById('start-btn').addEventListener('click', resetGame);
        animate();
    </script>
</body>
</html>
