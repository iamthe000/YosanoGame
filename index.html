<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>THE-AKIKO</title>
    <link rel="manifest" href="manifest.json">
    <script>
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js');
        }
    </script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'HiraMinProN-W6', 'Mincho', serif; touch-action: none; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        #score-board { color: white; font-size: 24px; padding: 20px; text-shadow: 0 0 5px red; font-weight: bold; position: absolute; top: 0; left: 0; z-index: 2; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; border: 2px solid lime; border-radius: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 10px lime; pointer-events: none; }
        
        #settings-btn {
            position: absolute; top: 20px; right: 150px;
            font-size: 24px; background: rgba(0,0,0,0.5); color: white; border: 1px solid white;
            width: 40px; height: 40px; border-radius: 50%; cursor: pointer; pointer-events: auto; z-index: 20;
            display: flex; justify-content: center; align-items: center;
        }
        #settings-btn:hover { background: rgba(255, 51, 102, 0.5); }

        #overlay, #settings-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: flex; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; z-index: 30; }
        #settings-overlay { display: none; z-index: 40; }

        h1 { color: #ff3366; font-size: 40px; margin-bottom: 10px; text-align: center; }
        p { color: #ddd; font-size: 18px; text-align: center; margin-bottom: 20px; line-height: 1.6; }
        
        button.menu-btn { padding: 10px 30px; font-size: 20px; background: #ff3366; color: white; border: none; border-radius: 5px; cursor: pointer; font-family: serif; margin-top: 20px; }
        button.menu-btn:active { background: #cc0033; }
        
        .setting-item { margin-bottom: 15px; width: 80%; max-width: 300px; color: white; text-align: left; }
        .setting-item label { display: inline-block; width: 100%; margin-bottom: 5px; font-weight: bold; }
        .setting-item input[type="range"] { width: 100%; cursor: pointer; }
        .setting-item input[type="checkbox"] { transform: scale(1.5); margin-right: 10px; cursor: pointer; }
        .setting-row { display: flex; align-items: center; margin-bottom: 10px; }

        #minimap-container {
            position: absolute; top: 20px; right: 20px; width: 120px; height: 120px;
            background: rgba(0, 20, 0, 0.7); border: 2px solid rgba(0, 255, 0, 0.6);
            border-radius: 50%; z-index: 5; overflow: hidden;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3); pointer-events: none; transition: opacity 0.3s;
        }
        #minimap { width: 100%; height: 100%; display: block; }

        #mobile-controls { position: absolute; width: 100%; height: 100%; display: none; pointer-events: none; top: 0; left: 0; }
        .control-zone { width: 50%; height: 100%; pointer-events: auto; position: absolute; bottom: 0; z-index: 5; }
        #left-zone { left: 0; } 
        #right-zone { right: 0; } 
        
        .action-btn {
            position: absolute; width: 70px; height: 70px;
            background: rgba(255, 51, 102, 0.5); border: 2px solid white; border-radius: 50%;
            pointer-events: auto; display: flex; align-items: center; justify-content: center;
            color: white; font-weight: bold; user-select: none; z-index: 6; font-size: 16px;
        }
        #fire-btn { background: rgba(255, 51, 102, 0.6); }
        #jump-btn { background: rgba(51, 102, 255, 0.6); }

        .pc-only { display: none; }
        @media (min-width: 1024px) {
            .pc-only { display: inline; }
            .mobile-only { display: none; }
            #mobile-controls { display: none !important; }
        }

        @media (max-width: 1023px) and (orientation: portrait) {
            #mobile-controls { display: block; }
            .control-zone { height: 40%; bottom: 0; }
            #fire-btn { bottom: 40px; right: 20px; }
            #jump-btn { bottom: 40px; right: 100px; width: 60px; height: 60px; font-size: 14px; }
            #minimap-container { top: 60px; right: 20px; width: 100px; height: 100px; }
            #settings-btn { top: 60px; right: 130px; } 
        }

        @media (max-width: 1023px) and (orientation: landscape) {
            #mobile-controls { display: block; }
            .control-zone { height: 100%; top: 0; }
            #fire-btn { bottom: 30px; right: 30px; }
            #jump-btn { bottom: 30px; right: 110px; width: 60px; height: 60px; font-size: 14px; }
            h1 { font-size: 32px; }
            #minimap-container { top: 15px; right: 15px; width: 100px; height: 100px; }
            #settings-btn { top: 15px; right: 125px; }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="ui-layer">
        <div id="score-board">撃墜数: <span id="score">0</span></div>
        <button id="settings-btn" title="設定">⚙️</button>
        <div id="minimap-container">
            <canvas id="minimap" width="120" height="120"></canvas>
        </div>
        <div id="crosshair"></div>
    </div>
    
    <div id="mobile-controls">
        <div id="left-zone" class="control-zone"></div>
        <div id="right-zone" class="control-zone"></div>
        <div id="fire-btn" class="action-btn">撃て</div>
        <div id="jump-btn" class="action-btn">跳</div>
    </div>

    <div id="overlay">
        <h1>THE-AKIKO<br><span style="font-size:20px;">- Cube World -</span></h1>
        <p>
            正六面体の荒野。<br>
            小さい箱は踏み台に、大きい箱は壁になる。<br>
            <br>
            <span class="pc-only">【PC】WASD:移動 | SPACE:ジャンプ | Click:射撃</span>
            <span class="mobile-only">【スマホ】左操作:移動 | 右操作:視点 | ボタン:射撃/跳躍</span>
        </p>
        <button id="start-btn" class="menu-btn">迎撃開始</button> 
        <a href="https://github.com/iamthe000/YosanoGame/" style="color:#666; font-size: 12px; margin-top:20px;">GitHub</a>
    </div>

    <div id="settings-overlay">
        <h2>環境設定</h2>
        <div class="setting-item">
            <label for="sens-slider">視点感度: <span id="sens-val">1.0</span></label>
            <input type="range" id="sens-slider" min="0.1" max="3.0" step="0.1" value="1.0">
        </div>
        <div class="setting-item setting-row">
            <input type="checkbox" id="hitbox-check">
            <label for="hitbox-check">当たり判定を表示</label>
        </div>
        <div class="setting-item setting-row">
            <input type="checkbox" id="minimap-check" checked>
            <label for="minimap-check">ミニマップを表示</label>
        </div>
        <button id="close-settings-btn" class="menu-btn">閉じる</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- ゲーム状態変数 ---
        let isGameRunning = false;
        let isSettingsOpen = false;
        let score = 0;
        let spawnRate = 100; 
        let enemySpeed = 0.05;
        let frame = 0;
        
        // --- 物理演算・移動パラメータ ---
        const playerSpeed = 0.15;
        const GRAVITY = 0.015;
        const JUMP_FORCE = 0.35; // 最大到達高さ 約4.0
        const PLAYER_HEIGHT = 1.6;
        const PLAYER_RADIUS = 0.5;
        
        // プレイヤー物理状態
        let playerVelocity = new THREE.Vector3();
        let isGrounded = false;
        
        let projectiles = [];
        let enemies = []; 
        let blocks = []; 

        // 設定値
        let config = { sensitivity: 1.0, showHitboxes: false, showMinimap: true };

        // --- Three.js Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x110505); 
        scene.fog = new THREE.Fog(0x110505, 10, 60);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.rotation.order = "YXZ"; 
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
        container.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xff3366, 1, 50);
        pointLight.position.set(0, 20, 0);
        scene.add(pointLight);

        const gridHelper = new THREE.GridHelper(200, 200, 0xff3366, 0x333333);
        scene.add(gridHelper);
        
        const floorPlane = new THREE.Mesh(
            new THREE.PlaneGeometry(200, 200),
            new THREE.MeshBasicMaterial({ visible: false })
        );
        floorPlane.rotation.x = -Math.PI / 2;
        scene.add(floorPlane);

        const playerHitbox = new THREE.Mesh(
            new THREE.CylinderGeometry(PLAYER_RADIUS, PLAYER_RADIUS, PLAYER_HEIGHT, 8),
            new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true, visible: false })
        );
        scene.add(playerHitbox);

        // --- テクスチャ ---
        let akikoMaterial;
        const textureLoader = new THREE.TextureLoader();
        textureLoader.load(
            './Akiko.png', 
            (texture) => { akikoMaterial = new THREE.SpriteMaterial({ map: texture }); },
            undefined,
            (err) => {
                const canvas = document.createElement('canvas');
                canvas.width = 64; canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'red'; ctx.fillRect(0,0,64,64);
                akikoMaterial = new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) });
            }
        );

        // --- 入力管理 ---
        const keys = { w: false, a: false, s: false, d: false, space: false };
        let mobileMove = { x: 0, y: 0 }; 
        
        document.addEventListener('keydown', (e) => { 
            const key = e.key.toLowerCase();
            if(keys.hasOwnProperty(key) || e.code === 'Space') {
                if(e.code === 'Space') keys.space = true; else keys[key] = true;
            }
        });
        document.addEventListener('keyup', (e) => { 
            const key = e.key.toLowerCase();
            if(keys.hasOwnProperty(key) || e.code === 'Space') {
                if(e.code === 'Space') keys.space = false; else keys[key] = false;
            }
        });
        
        document.addEventListener('click', (e) => {
            if (e.target.closest('.action-btn') || e.target.closest('#settings-btn') || e.target.closest('#settings-overlay')) return;
            if (isGameRunning && !isSettingsOpen) {
                if(!isMobile() && document.pointerLockElement !== document.body) document.body.requestPointerLock();
                if(!isMobile()) shoot();
            }
        });
        
        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement === document.body && !isSettingsOpen) {
                camera.rotation.y -= e.movementX * 0.002 * config.sensitivity;
                camera.rotation.x -= e.movementY * 0.002 * config.sensitivity;
                camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
            }
        });

        const leftZone = document.getElementById('left-zone');
        const rightZone = document.getElementById('right-zone');
        const fireBtn = document.getElementById('fire-btn');
        const jumpBtn = document.getElementById('jump-btn');
        let touchStartPos = { left: null, right: null };

        function handleTouchStart(e, side) {
            if (isSettingsOpen) return;
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                touchStartPos[side] = { id: t.identifier, x: t.clientX, y: t.clientY };
            }
        }

        function handleTouchMove(e, side) {
            if (isSettingsOpen) return;
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                if (touchStartPos[side] && touchStartPos[side].id === t.identifier) {
                    const dx = t.clientX - touchStartPos[side].x;
                    const dy = t.clientY - touchStartPos[side].y;
                    
                    if (side === 'left') {
                        const moveSensitivity = 0.01; 
                        mobileMove.x = Math.max(-1, Math.min(1, dx * moveSensitivity));
                        mobileMove.y = Math.max(-1, Math.min(1, dy * moveSensitivity));
                    } else {
                        camera.rotation.y -= dx * 0.004 * config.sensitivity;
                        camera.rotation.x -= dy * 0.004 * config.sensitivity;
                        camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
                        touchStartPos[side].x = t.clientX; 
                        touchStartPos[side].y = t.clientY;
                    }
                }
            }
        }

        function handleTouchEnd(e, side) {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (touchStartPos[side] && touchStartPos[side].id === e.changedTouches[i].identifier) {
                    touchStartPos[side] = null;
                    if (side === 'left') { mobileMove = { x: 0, y: 0 }; }
                }
            }
        }

        leftZone.addEventListener('touchstart', (e) => handleTouchStart(e, 'left'), {passive: false});
        leftZone.addEventListener('touchmove', (e) => handleTouchMove(e, 'left'), {passive: false});
        leftZone.addEventListener('touchend', (e) => handleTouchEnd(e, 'left'), {passive: false});
        rightZone.addEventListener('touchstart', (e) => handleTouchStart(e, 'right'), {passive: false});
        rightZone.addEventListener('touchmove', (e) => handleTouchMove(e, 'right'), {passive: false});
        rightZone.addEventListener('touchend', (e) => handleTouchEnd(e, 'right'), {passive: false});
        fireBtn.addEventListener('touchstart', (e) => { e.preventDefault(); if(isGameRunning && !isSettingsOpen) shoot(); }, {passive: false});
        jumpBtn.addEventListener('touchstart', (e) => { e.preventDefault(); if(isGameRunning && !isSettingsOpen) playerJump(); }, {passive: false});

        function isMobile() { return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent); }

        // --- ブロック生成 (修正版) ---
        function createRandomBlocks() {
            blocks.forEach(b => scene.remove(b.mesh));
            blocks = [];

            const boxGeo = new THREE.BoxGeometry(1, 1, 1);
            const boxMat = new THREE.MeshLambertMaterial({ color: 0x555555 });
            const edgeGeo = new THREE.EdgesGeometry(boxGeo);
            const edgeMat = new THREE.LineBasicMaterial({ color: 0x00ff00 });

            for (let i = 0; i < 40; i++) {
                // 30%の確率でデカい箱、70%で通常箱
                const isBig = Math.random() < 0.3; 
                
                // 通常サイズ(3): ジャンプ力0.35で乗れるギリギリのサイズ(余裕を見て3.0)
                // 2倍サイズ(6): 通常ジャンプでは乗れない。小さい箱を経由する必要がある。
                const size = isBig ? 6 : 3; 
                
                const mesh = new THREE.Mesh(boxGeo, boxMat);
                mesh.scale.set(size, size, size); // 正六面体
                
                let x, z;
                // スタート地点付近は空ける
                do {
                    x = (Math.random() - 0.5) * 120;
                    z = (Math.random() - 0.5) * 120;
                } while(Math.abs(x) < 10 && Math.abs(z) < 10);

                mesh.position.set(x, size / 2, z); // 底面を0に合わせる
                scene.add(mesh);

                const edges = new THREE.LineSegments(edgeGeo, edgeMat);
                mesh.add(edges);

                blocks.push({ mesh: mesh, box: new THREE.Box3().setFromObject(mesh) });
            }
        }

        // --- ゲーム管理関数 ---
        function resetGame() {
            score = 0;
            spawnRate = 100;
            enemySpeed = 0.05;
            document.getElementById('score').innerText = score;
            
            enemies.forEach(e => { scene.remove(e.sprite); if(e.hitbox) scene.remove(e.hitbox); });
            projectiles.forEach(p => scene.remove(p));
            enemies = [];
            projectiles = [];
            
            camera.position.set(0, 10, 0); 
            playerVelocity.set(0, 0, 0);
            camera.rotation.set(0, 0, 0);
            
            createRandomBlocks();

            isGameRunning = true;
            isSettingsOpen = false;
            document.getElementById('overlay').style.display = 'none';
        }

        function gameOver() {
            isGameRunning = false;
            document.querySelector('#overlay h1').innerHTML = "GAME OVER";
            document.querySelector('#overlay p').innerHTML = `撃墜数: ${score}体<br>君は死にたまひぬ。`;
            document.getElementById('start-btn').innerText = "再挑戦";
            document.getElementById('overlay').style.display = 'flex';
            if (document.exitPointerLock) document.exitPointerLock();
        }

        function shoot() {
            const geometry = new THREE.SphereGeometry(0.1, 8, 8);
            const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const bullet = new THREE.Mesh(geometry, material);
            bullet.position.copy(camera.position);
            bullet.position.y -= 0.2; 
            const cameraDir = new THREE.Vector3();
            camera.getWorldDirection(cameraDir);
            bullet.velocity = cameraDir.multiplyScalar(1.0); 
            scene.add(bullet);
            projectiles.push(bullet);
        }

        function playerJump() {
            if (isGrounded) {
                playerVelocity.y = JUMP_FORCE;
                isGrounded = false;
            }
        }

        function spawnEnemy() {
            if (!akikoMaterial) return; 
            const sprite = new THREE.Sprite(akikoMaterial);
            sprite.scale.set(1.5, 1.5, 1);
            const angle = Math.random() * Math.PI * 2;
            const radius = 30 + Math.random() * 20; 
            sprite.position.set(
                camera.position.x + Math.cos(angle) * radius,
                20, 
                camera.position.z + Math.sin(angle) * radius
            );
            scene.add(sprite);

            const hitbox = new THREE.Mesh(
                new THREE.SphereGeometry(1.0, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true, visible: config.showHitboxes })
            );
            scene.add(hitbox);

            enemies.push({ sprite: sprite, hitbox: hitbox, velocity: new THREE.Vector3(0, 0, 0), isGrounded: false });
        }

        // --- 物理衝突判定 ---
        function checkCollision(pos, radius, height, velocity) {
            let grounded = false;
            let nextY = pos.y + velocity.y;
            
            // 床
            if (nextY < height/2) {
                nextY = height/2;
                if (velocity.y < 0) { velocity.y = 0; grounded = true; }
            }

            // ブロック (Y軸)
            const pMinX = pos.x - radius; const pMaxX = pos.x + radius;
            const pMinZ = pos.z - radius; const pMaxZ = pos.z + radius;
            
            for (let b of blocks) {
                const bMin = b.box.min; const bMax = b.box.max;
                if (pMaxX > bMin.x && pMinX < bMax.x && pMaxZ > bMin.z && pMinZ < bMax.z) {
                    if (pos.y - height/2 >= bMax.y - 0.2 && velocity.y <= 0) {
                        if (nextY - height/2 < bMax.y) {
                            nextY = bMax.y + height/2;
                            velocity.y = 0; grounded = true;
                        }
                    }
                }
            }
            pos.y = nextY;

            // 水平移動
            let nextX = pos.x + velocity.x;
            let nextZ = pos.z + velocity.z;
            
            for (let b of blocks) {
                const bMin = b.box.min; const bMax = b.box.max;
                const myBottom = pos.y - height/2 + 0.1; 
                const myTop = pos.y + height/2 - 0.1;

                if (myTop > bMin.y && myBottom < bMax.y) {
                    if (nextX + radius > bMin.x && nextX - radius < bMax.x && 
                        pos.z + radius > bMin.z && pos.z - radius < bMax.z) {
                        nextX = pos.x; velocity.x = 0;
                    }
                    if (nextX + radius > bMin.x && nextX - radius < bMax.x && 
                        nextZ + radius > bMin.z && nextZ - radius < bMax.z) {
                        nextZ = pos.z; velocity.z = 0;
                    }
                }
            }
            pos.x = nextX;
            pos.z = nextZ;
            return grounded;
        }

        function updateEnemyPhysics(eData, targetPos) {
            const e = eData.sprite;
            const radius = 0.8;
            const height = 1.5;

            eData.velocity.y -= GRAVITY;
            const dir = new THREE.Vector3().subVectors(targetPos, e.position);
            dir.y = 0; dir.normalize();
            
            if (eData.isGrounded) {
                eData.velocity.x = dir.x * enemySpeed;
                eData.velocity.z = dir.z * enemySpeed;
            } else {
                eData.velocity.x *= 0.95; eData.velocity.z *= 0.95;
            }

            // Y軸
            let nextY = e.position.y + eData.velocity.y;
            eData.isGrounded = false;
            if (nextY < height/2) { nextY = height/2; eData.velocity.y = 0; eData.isGrounded = true; }

            const pMinX = e.position.x - radius; const pMaxX = e.position.x + radius;
            const pMinZ = e.position.z - radius; const pMaxZ = e.position.z + radius;
            
            for (let b of blocks) {
                const bMin = b.box.min; const bMax = b.box.max;
                if (pMaxX > bMin.x && pMinX < bMax.x && pMaxZ > bMin.z && pMinZ < bMax.z) {
                    if (e.position.y - height/2 >= bMax.y - 0.5 && eData.velocity.y <= 0) {
                        if (nextY - height/2 < bMax.y) {
                            nextY = bMax.y + height/2;
                            eData.velocity.y = 0; eData.isGrounded = true;
                        }
                    }
                }
            }
            e.position.y = nextY;

            // 水平
            let nextX = e.position.x + eData.velocity.x;
            let nextZ = e.position.z + eData.velocity.z;
            let hitWall = false;

            for (let b of blocks) {
                const bMin = b.box.min; const bMax = b.box.max;
                const myBottom = e.position.y - height/2 + 0.2;
                const myTop = e.position.y + height/2 - 0.2;

                if (myTop > bMin.y && myBottom < bMax.y) {
                    if (nextX + radius > bMin.x && nextX - radius < bMax.x && 
                        e.position.z + radius > bMin.z && e.position.z - radius < bMax.z) {
                        nextX = e.position.x; hitWall = true;
                    }
                    if (nextX + radius > bMin.x && nextX - radius < bMax.x && 
                        nextZ + radius > bMin.z && nextZ - radius < bMax.z) {
                        nextZ = e.position.z; hitWall = true;
                    }
                }
            }

            if (hitWall && eData.isGrounded && targetPos.y > e.position.y) {
                eData.velocity.y = 0.35; 
                eData.isGrounded = false;
                eData.velocity.x += dir.x * 0.1; eData.velocity.z += dir.z * 0.1;
            }

            e.position.x = nextX; e.position.z = nextZ;
            if(eData.hitbox) eData.hitbox.position.copy(e.position);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
            if (!isGameRunning || isSettingsOpen) return;
            frame++;

            if (keys.space) playerJump();

            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            direction.y = 0; direction.normalize();
            const right = new THREE.Vector3();
            right.crossVectors(direction, camera.up).normalize();

            let moveX = 0, moveZ = 0;
            if (keys.w) { moveX += direction.x; moveZ += direction.z; }
            if (keys.s) { moveX -= direction.x; moveZ -= direction.z; }
            if (keys.d) { moveX += right.x; moveZ += right.z; }
            if (keys.a) { moveX -= right.x; moveZ -= right.z; }
            if (Math.abs(mobileMove.x) > 0 || Math.abs(mobileMove.y) > 0) {
                moveX += right.x * mobileMove.x - direction.x * mobileMove.y;
                moveZ += right.z * mobileMove.x - direction.z * mobileMove.y;
            }

            playerVelocity.x = moveX * playerSpeed;
            playerVelocity.z = moveZ * playerSpeed;
            playerVelocity.y -= GRAVITY;

            isGrounded = checkCollision(camera.position, PLAYER_RADIUS, PLAYER_HEIGHT, playerVelocity);
            if(camera.position.y < -10) camera.position.set(0, 10, 0);
            playerHitbox.position.copy(camera.position);

            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.position.add(p.velocity);
                if (p.position.distanceTo(camera.position) > 80) { scene.remove(p); projectiles.splice(i, 1); continue; }
                
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const eData = enemies[j];
                    if (p.position.distanceTo(eData.sprite.position) < 1.5) { 
                        scene.remove(eData.sprite);
                        if(eData.hitbox) scene.remove(eData.hitbox);
                        enemies.splice(j, 1);
                        scene.remove(p);
                        projectiles.splice(i, 1);
                        score++;
                        document.getElementById('score').innerText = score;
                        if(score % 5 === 0) spawnRate = Math.max(20, spawnRate - 5);
                        if(score % 10 === 0) enemySpeed += 0.005;
                        break; 
                    }
                }
                for (let b of blocks) {
                    if (b.box.containsPoint(p.position)) {
                        scene.remove(p); projectiles.splice(i, 1); break;
                    }
                }
            }

            if (frame % spawnRate === 0) spawnEnemy();

            for (let i = 0; i < enemies.length; i++) {
                const eData = enemies[i];
                updateEnemyPhysics(eData, camera.position);
                if (eData.sprite.position.distanceTo(camera.position) < 1.2) gameOver();
            }
            updateMinimap();
        }

        const minimapCtx = document.getElementById('minimap').getContext('2d');
        function updateMinimap() {
            if (!config.showMinimap) return;
            minimapCtx.clearRect(0, 0, 120, 120);
            minimapCtx.strokeStyle = 'rgba(0, 255, 0, 0.2)';
            minimapCtx.lineWidth = 1;
            minimapCtx.beginPath();
            minimapCtx.arc(60, 60, 30, 0, Math.PI * 2);
            minimapCtx.stroke();
            
            minimapCtx.fillStyle = '#00ff00';
            minimapCtx.beginPath();
            minimapCtx.moveTo(60, 55); minimapCtx.lineTo(56, 64); minimapCtx.lineTo(64, 64); minimapCtx.fill();

            const pDir = new THREE.Vector3(); camera.getWorldDirection(pDir); pDir.y=0; pDir.normalize();
            const pRight = new THREE.Vector3().crossVectors(pDir, camera.up).normalize();

            minimapCtx.fillStyle = '#ff3366'; 
            enemies.forEach(e => {
                const rel = new THREE.Vector3().subVectors(e.sprite.position, camera.position);
                const dist = Math.sqrt(rel.x*rel.x + rel.z*rel.z);
                if (dist < 40) {
                    const f = rel.x * pDir.x + rel.z * pDir.z;
                    const r = rel.x * pRight.x + rel.z * pRight.z;
                    minimapCtx.beginPath(); minimapCtx.arc(60 + r/40*60, 60 - f/40*60, 3, 0, Math.PI * 2); minimapCtx.fill();
                }
            });
        }

        const settingsBtn = document.getElementById('settings-btn');
        const settingsOverlay = document.getElementById('settings-overlay');
        const closeSettingsBtn = document.getElementById('close-settings-btn');
        
        settingsBtn.addEventListener('click', () => { isSettingsOpen = true; settingsOverlay.style.display = 'flex'; if (document.exitPointerLock) document.exitPointerLock(); });
        closeSettingsBtn.addEventListener('click', () => { 
            isSettingsOpen = false; settingsOverlay.style.display = 'none'; 
            if (isGameRunning && !isMobile()) document.body.requestPointerLock();
        });

        document.getElementById('sens-slider').addEventListener('input', (e) => { config.sensitivity = parseFloat(e.target.value); document.getElementById('sens-val').innerText = config.sensitivity.toFixed(1); });
        document.getElementById('hitbox-check').addEventListener('change', (e) => { config.showHitboxes = e.target.checked; enemies.forEach(e => { if(e.hitbox) e.hitbox.material.visible = config.showHitboxes; }); playerHitbox.material.visible = config.showHitboxes; });
        document.getElementById('minimap-check').addEventListener('change', (e) => { config.showMinimap = e.target.checked; document.getElementById('minimap-container').style.opacity = config.showMinimap ? '1' : '0'; });

        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
        document.getElementById('start-btn').addEventListener('click', resetGame);
        animate();
    </script>
</body>
</html>
